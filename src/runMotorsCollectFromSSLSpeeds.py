from socket import socket, AF_INET, SOCK_DGRAM
import CommTypes_pb2 as pb
import time
import datetime
import numpy as np

def recvSSLMessage(udp_sock):
        msg = pb.protoMotorsDataSSL()
        # multiple messages are received and accumulated on buffer during vision processing
        # so read until buffer socket are no longer available
        has_msg = False
        while True:
            try:
                data, _ = udp_sock.recvfrom(1024)
                msg.ParseFromString(data)
                has_msg = True
            except:
                break 
        current_speeds = [msg.current_m1, msg.current_m2, msg.current_m3, msg.current_m4]
        pwms = [msg.pwm_m1, msg.pwm_m2, msg.pwm_m3, msg.pwm_m4]
        desired_speeds = [msg.desired_m1, msg.desired_m2, msg.desired_m3, msg.desired_m4]
        timestamp = msg.msgTime
        
        return has_msg, current_speeds, pwms, desired_speeds, timestamp

def serializeMsgToLog(current_speeds, pwms, desired_speeds, timestamp):
    print(f"current: {current_speeds[0]}, desired: {desired_speeds[0]}, pwm: {pwms[0]} | timestamp: {timestamp:.3f}")
    return current_speeds[0], current_speeds[1], current_speeds[2], current_speeds[3], \
        pwms[0], pwms[1], pwms[2], pwms[3], \
        desired_speeds[0], desired_speeds[1], desired_speeds[2], desired_speeds[3], \
        timestamp

if __name__ ==  "__main__":
    server = "199.0.1.1"
    pc2robot_port = 9600
    robot2pc_port = 9601
    
    msg = pb.protoMotorsPWMSSL()
    conn = socket(AF_INET, SOCK_DGRAM)
    conn.bind(('', robot2pc_port))
    conn.settimeout(0)

    # CHANGE LIST TO PSEUDO-RANDOM VALUES GENERATED BY VICTOR
    sleep_between_iterations_ms = 0.25
    maximum_time_without_messages_s = 2
    
    log = []
    
    # START MSG TIME COUNTER
    start = time.time()
    msgTimeout = time.time()
    received_first_msg = False
    time_offset = 0
    last_timestamp = 0

    while True:
        # SLEEP
        time.sleep(sleep_between_iterations_ms/1000)

        # RECV MESSAGE
        has_msg, current_speeds, pwms, desired_speeds, timestamp_data = recvSSLMessage(conn)
        if has_msg:
            if timestamp_data - last_timestamp < 0:
                time_offset += last_timestamp
            last_timestamp = timestamp_data
            log_msg = serializeMsgToLog(current_speeds, pwms, desired_speeds, timestamp_data+time_offset)
            log.append(log_msg)
            received_first_msg = True
            msgTimeout = time.time()
        elif ((time.time() - msgTimeout) > maximum_time_without_messages_s) and received_first_msg:
            break

        # COUNT TIME
        elapsed_time = time.time() - start
        if (elapsed_time > 120) and received_first_msg:
            break

        #print(f'Elapsed msgTimeout: {time.time() - msgTimeout:.3f} | First Msg: {received_first_msg}')

    if len(log)>0:
        # Get the current date and time
        current_datetime = datetime.datetime.now()
        
        # Format the date and time as a string
        formatted_datetime = current_datetime.strftime("%Y-%m-%d_%H-%M-%S")

        print(f"Saving motors log: {len(log)}")
        names = 'CURRENT_M1, CURRENT_M2, CURRENT_M3, CURRENT_M4, PWM_M1, PWM_M2, PWM_M3, PWM_M4, DESIRED_M1, DESIRED_M2, DESIRED_M3, DESIRED_M4, TIMESTAMP'
        np.savetxt(f'./results/motor_log_{formatted_datetime}.csv', \
                   log,
                   delimiter=',',
                   header=names)
    else:
        print("Empty log!")
    
    print("Finish")
